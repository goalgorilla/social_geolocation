<?php

/**
 * @file
 * Contains hook implementations for the Social Geolocation module.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\node\NodeInterface;
use Drupal\views\Plugin\views\cache\CachePluginBase;
use Drupal\views\Plugin\views\query\QueryPluginBase;
use Drupal\views\ViewExecutable;

/**
 * Implements hook_help().
 */
function social_geolocation_maps_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.social_geolocation_maps':
      return 'This module provides a Map on the events page. Enable the module and create an event with an address so it shows up on the map.';
  }
  return NULL;
}

/**
 * Implements hook_field_widget_form_alter().
 */
function social_geolocation_maps_field_widget_form_alter(&$element, FormStateInterface $form_state, $context) {
  // Change title in form for adding Event Maps block on Landing pages.
  if ($context['items']->getName() === 'field_block_reference' ||
    $context['items']->getName() === 'field_block_reference_secondary') {
    $name = $element['plugin_id']['#options']['Basic']['views_block:social_geolocation_leaflet_commonmap_with_marker_icons-block_upcomming_events_map'];

    if ($name !== NULL) {
      $element['plugin_id']['#options']['Basic']['views_block:social_geolocation_leaflet_commonmap_with_marker_icons-block_upcomming_events_map'] = t('Upcoming Events shown on a map');
    }
  }
}

/**
 * Implements hook_views_query_alter().
 */
function social_geolocation_maps_views_query_alter(ViewExecutable $view, QueryPluginBase $query) {
  // Due to issues with grouped filters I have to switch >= to < myself when
  // user changes upcoming events to events in the past.
  if ($view->id() === 'social_geolocation_leaflet_commonmap_with_marker_icons' &&
    $view->getDisplay()->display['id'] === 'block_community_events_map') {
    $query_args = $view->getRequest()->get('field_event_date_value');

    // If there are query parameters set for the field_event_date_value we
    // make sure the query reflects this before execution.
    if ($query_args !== NULL) {
      $exposed = $view->getExposedInput();
      $filter = $exposed['field_event_date_value'];

      if ($filter !== NULL) {
        // Grab all the filter options.
        $filter_options = $view->display_handler->getOption('filters');

        // Based on the number from the Grouped value, grab the correct
        // operator.
        $operator = $filter_options['field_event_date_value']['group_info']['group_items'][$query_args]['operator'];

        // Switch the operator field.
        foreach ($query->where[1]['conditions'] as $key => $options) {
          if ($operator !== NULL && strpos($options['field'], 'node__field_event_date.field_event_date_value') !== FALSE) {
            $field = "DATE_FORMAT(node__field_event_date.field_event_date_value, '%Y-%m-%d\T%H:%i:%s') " . $operator . " DATE_FORMAT('" . date('Y-m-d\TH:i:s') . "', '%Y-%m-%d\T%H:%i:%s')";
            $query->where[1]['conditions'][$key]['field'] = $field;
          }
        }
      }
    }
  }
}

/**
 * Implements hook_page_attachments_alter().
 */
function social_geolocation_maps_page_attachments_alter(array &$attachments) {
  $route_name = \Drupal::routeMatch()->getRouteName();

  // If bigpipe is enabled, the attachments don't get loaded for LU.
  // So this is necessary to fix https://www.drupal.org/node/3018719.
  if ($route_name === 'view.upcoming_events.page_community_events'
    && \Drupal::moduleHandler()->moduleExists('social_geolocation')
    && \Drupal::moduleHandler()->moduleExists('big_pipe')
    && !\Drupal::currentUser()->isAnonymous()) {

    $attachments['#attached']['library'][] = 'geolocation_leaflet/widget.leaflet';
    $attachments['#attached']['library'][] = 'geolocation_leaflet/geolocation.leaflet';
    $attachments['#attached']['library'][] = 'geolocation_leaflet/leaflet.markerclusterer';
  }

}

/**
 * Implements hook_preprocess_field().
 */
function social_geolocation_maps_preprocess_field(&$variables) {
  if ($variables['element']['#formatter'] === 'geolocation_address') {
    $entity = $variables['element']['#object'];
    if ($entity && $entity instanceof NodeInterface && $entity->getType() === 'event') {
      $social_event_settings = \Drupal::config('social_event.settings');
      $address_visibility_settings = $social_event_settings->get('address_visibility_settings');
      if (isset($address_visibility_settings['street_code_private']) && !empty($address_visibility_settings['street_code_private'])) {
        if (!_social_event_get_enrollment_status($entity) && isset($variables['items'][0]['content'][0]['#coordinates'])) {
          $lat = $variables['items'][0]['content'][0]['#coordinates']['lat'];
          $lng = $variables['items'][0]['content'][0]['#coordinates']['lng'];

          $variables['items'][0]['content'][0]['#coordinates']['lat'] = (string) ($lat + (rand(-9, 9) / 100));
          $variables['items'][0]['content'][0]['#coordinates']['lng'] = (string) ($lng + (rand(-9, 9) / 100));
        }
      }
    }
  }
}

/**
 * Implements hook_views_post_render().
 */
function social_geolocation_maps_views_post_render(ViewExecutable $view, &$output, CachePluginBase $cache) {
  if (in_array($view->current_display, ['block_upcomming_events_map', 'block_community_events_map']) && $view->id() === 'social_geolocation_leaflet_commonmap_with_marker_icons' && isset($output['#rows'])) {
    $social_event_settings = \Drupal::config('social_event.settings');
    $address_visibility_settings = $social_event_settings->get('address_visibility_settings');
    if (!isset($address_visibility_settings['street_code_private']) || empty($address_visibility_settings['street_code_private'])) {
      return;
    }

    foreach ($output['#rows']['locations'] as &$location) {
      $entity = $location['content']['#node'];
      if ($entity && $entity instanceof NodeInterface && $entity->getType() === 'event') {
        if (!_social_event_get_enrollment_status($entity) && isset($location['#position'])) {
          $lat = $location['#position']['lat'];
          $lng = $location['#position']['lng'];

          $location['#position']['lat'] = (string) ($lat + (rand(-9, 9) / 100));
          $location['#position']['lng'] = (string) ($lng + (rand(-9, 9) / 100));
        }
      }
    }
  }
}
